#!/usr/bin/env python
# =====================================================================================
#                   Python script to plot data from the Huckel analysis
# -------------------------------------------------------------------------------------
#
#     Author: Rony J. Letona
#     email:  rony.letona@estudiante.uam.es
#     Date:   March, 2022
#
# =====================================================================================

# Importing the system module to be able to capture command line arguments
import sys

# Checking if a command line argument was given. If not, use the default.
if len(sys.argv) == 2:
    file_name = sys.argv[1]
else:
    print("The provided command line arguments are not what was expected.")
    print("Please provide the script with:\n\n")
    print("- name_of_molecule  :  tha name of the molecule whose files got")
    print("                       generated by the huckel.exe program.")
    print("                       Do NOT include and extension!\n")
    print("Quitting ...")
    quit()

# Try importing the plotting module. If it's not possible ... quit.
try:
    from matplotlib import pyplot as plt
    import matplotlib.cm as cm
except ImportError as e:
    print(e)
    print("Please make sure you have MatPlotLib installed in your computer.")
    quit()

# Try importing the plotting module. If it's not possible ... quit.
try:
    import numpy as np
except ImportError as e:
    print(e)
    print("Please make sure you have NumPy installed in your computer.")
    quit()

# Function to compute the actual wave function density in a given point in space
def Psi(x, y, z, x0, y0, z0):
    r = ((x - x0)**2 + (y - y0)**2 + (z - z0)**2)**0.5
    A = (3.25**5 / (32*np.pi))**0.5
    ex = -3.25 * r / 2
    return A * (z - z0) * np.e**ex

# Function to plot the 2D orbitals
def orbital2D(coords, constants, z=1, orbital=0, delta=0.05):
    if len(coords) != len(constants):
        raise ValueError("The number of coordinates fails with respect to the number of constants.")
    z = 1/z                                             # Making the charge work
    n = len(coords)                                     # The number of coords
    lx = min([c[0] for c in coords])                    # Finding minimum value of x
    ux = max([c[0] for c in coords])                    # Finding maximim value of x
    ly = min([c[1] for c in coords])                    # Finding minimum value of y
    uy = max([c[1] for c in coords])                    # Finding maximim value of y
    domx = np.arange(lx - 1.5, ux + 1.5 + delta, delta) # Creating a new domain of x
    domy = np.arange(ly - 1.5, uy + 1.5 + delta, delta) # Creating a new domain of y
    densmap = [[0]*len(domx)]*len(domy)                 # Building a matrix for the density
    for iy in range(len(domy)):                         # Sweeping through all x and y
        for ix in range(len(domx)):
            densmap[iy][ix] = 0
            for i in range(n):                          # And compute the electron density
                p = Psi(domx[ix], domy[iy], z, coords[i][0], coords[i][1], coords[i][2])
                densmap[iy][ix] += ( constants[i][orbital] * p )
        densmap[iy] = tuple(densmap[iy])                # Making this row unchangable
    dm = np.array(densmap, dtype=np.float32)
    plt.imshow(dm, cmap=cm.viridis)                     # Plot the heatmap
    plt.grid(False)                                     # Remove the grid
    plt.axis('equal')                                   # Make axis of equal size
    plt.axis('off')                                     # Remove the axes
    plt.savefig("orbital_{}.png".format(orbital+1), dpi=300)

# Reading the coordinates
coords = []
with open(f"{file_name}.xyz", "r") as xyz:
    for l in xyz.readlines():
        temp = l.split()
        if ((len(temp) == 4) and (len(temp[0]) == 1) and (temp[0] != "H")):
            coords.append([ float(c) for c in temp[1:] ])

# Reading the eigenvectors
eigenvects = []
with open(f"{file_name}_eigenvectors.dat", "r") as ev:
    for l in ev.readlines():
        temp = l.split()
        eigenvects.append([ float(v) for v in temp ])

# Transforming the eigenvectors into a NumPy array
eigenvects = np.array(eigenvects)

# Create all plots
for o in range(len(coords)):
    orbital2D(coords, eigenvects, z=6, orbital=o, delta=0.03)